/*
    â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—        â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—       â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
    â–ˆâ–ˆâ•‘      â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   
    â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â•â•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘       â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
    â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•        â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   
                                                                                                       
    ğŸº LXR Whitelist - Application Evaluation Engine
    
    This evaluation engine provides AI-powered scoring and analysis for RedM
    roleplay server whitelist applications. Built specifically for Georgian RP
    with comprehensive criteria and detailed feedback generation.
    
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    SERVER INFORMATION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    Server:      The Land of Wolves ğŸº
    Tagline:     Georgian RP ğŸ‡¬ğŸ‡ª | áƒ›áƒ’áƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒ˜áƒ¬áƒ - áƒ áƒ©áƒ”áƒ£áƒšáƒ—áƒ áƒáƒ“áƒ’áƒ˜áƒšáƒ˜!
    Description: áƒ˜áƒ¡áƒ¢áƒáƒ áƒ˜áƒ áƒªáƒáƒªáƒ®áƒšáƒ“áƒ”áƒ‘áƒ áƒáƒ¥! (History Lives Here!)
    Type:        Serious Hardcore Roleplay
    Access:      Discord & Whitelisted
    
    Developer:   iBoss21 / The Lux Empire
    Website:     https://www.wolves.land
    Discord:     https://discord.gg/CrKcWdfd3A
    GitHub:      https://github.com/iBoss21
    Store:       https://theluxempire.tebex.io
    Server:      https://servers.redm.net/servers/detail/8gj7eb
    
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    Version: 1.0.0
    Performance Target: Optimized for instant evaluation with detailed feedback
    
    Tags: RedM, Georgian, SeriousRP, Whitelist, Evaluation, AI, Scoring
    
    Framework Support:
    - LXR Core (Primary)
    - RSG Core (Compatible)
    - VORP Core (Compatible)
    - Standalone (Frontend Web Application)
    
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    CREDITS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    Script Author: iBoss21 / The Lux Empire for The Land of Wolves
    Original Concept: Whitelist evaluation system for Georgian RP
    Inspired by: Professional recruitment and HR evaluation systems
    
    Â© 2026 iBoss21 / The Lux Empire | wolves.land | All Rights Reserved
*/

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸº EVALUATION ENGINE CORE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Evaluation criteria and scoring weights
 */
export const EVALUATION_CRITERIA = {
  loreConsistency: {
    name: 'áƒšáƒáƒ áƒ˜ áƒ“áƒ áƒ”áƒáƒáƒ¥áƒáƒ¡áƒ—áƒáƒœ áƒ¨áƒ”áƒ¡áƒáƒ‘áƒáƒ›áƒ˜áƒ¡áƒáƒ‘áƒ',
    nameEn: 'Lore & Era Consistency',
    weight: 0.15,
    maxScore: 10
  },
  characterDepth: {
    name: 'áƒáƒ”áƒ áƒ¡áƒáƒœáƒáƒŸáƒ˜áƒ¡ áƒ¡áƒ˜áƒ¦áƒ áƒ›áƒ”',
    nameEn: 'Character Depth',
    weight: 0.20,
    maxScore: 10
  },
  motivationClarity: {
    name: 'áƒ›áƒáƒ¢áƒ˜áƒ•áƒáƒªáƒ˜áƒ˜áƒ¡ áƒ¡áƒ˜áƒªáƒ®áƒáƒ“áƒ”',
    nameEn: 'Motivation Clarity',
    weight: 0.20,
    maxScore: 10
  },
  rpSustainability: {
    name: 'RP áƒ›áƒ“áƒ’áƒ áƒáƒ“áƒáƒ‘áƒ',
    nameEn: 'RP Sustainability',
    weight: 0.20,
    maxScore: 10
  },
  risks: {
    name: 'áƒ áƒ˜áƒ¡áƒ™áƒ”áƒ‘áƒ˜ / áƒ¬áƒ˜áƒ—áƒ”áƒšáƒ˜ áƒœáƒ˜áƒ¨áƒœáƒ”áƒ‘áƒ˜',
    nameEn: 'Risk / Red Flags',
    weight: 0.15,
    maxScore: 10
  },
  languageStructure: {
    name: 'áƒ”áƒœáƒ áƒ“áƒ áƒ¡áƒ¢áƒ áƒ£áƒ¥áƒ¢áƒ£áƒ áƒ',
    nameEn: 'Language & Structure',
    weight: 0.10,
    maxScore: 10
  }
};

export const MINIMUM_PASSING_SCORE = 8.0;

/**
 * Parse whitelist application text into structured data
 */
export function parseApplication(text) {
  const lines = text.split('\n').filter(line => line.trim());
  
  const application = {
    rawText: text,
    fields: {}
  };
  
  // Extract fields using regex patterns
  const fieldPatterns = {
    name: /áƒ¡áƒáƒ®áƒ”áƒšáƒ˜ áƒ“áƒ áƒ’áƒ•áƒáƒ áƒ˜.*?:\s*(.+)/i,
    age: /áƒáƒ¡áƒáƒ™áƒ˜.*?:\s*(\d+)/i,
    origin: /áƒ¬áƒáƒ áƒ›áƒáƒ¨áƒáƒ‘áƒ áƒ“áƒ áƒ‘áƒáƒ•áƒ¨áƒ•áƒáƒ‘áƒ.*?:\s*(.+)/i,
    character: /áƒ®áƒáƒ¡áƒ˜áƒáƒ—áƒ˜ áƒ“áƒ áƒ¥áƒªáƒ”áƒ•áƒ.*?:\s*(.+)/i,
    weaknesses: /áƒ¡áƒ˜áƒ¡áƒ£áƒ¡áƒ¢áƒ”áƒ”áƒ‘áƒ˜ áƒ“áƒ áƒ¨áƒ˜áƒ¨áƒ”áƒ‘áƒ˜.*?:\s*(.+)/i,
    conflictAttitude: /áƒ™áƒáƒœáƒ¤áƒšáƒ˜áƒ¥áƒ¢áƒ˜áƒ¡áƒáƒ“áƒ›áƒ˜ áƒ“áƒáƒ›áƒáƒ™áƒ˜áƒ“áƒ”áƒ‘áƒ£áƒšáƒ”áƒ‘áƒ.*?:\s*(.+)/i,
    currentState: /áƒ›áƒ˜áƒ›áƒ“áƒ˜áƒœáƒáƒ áƒ” áƒ›áƒ“áƒ’áƒáƒ›áƒáƒ áƒ”áƒáƒ‘áƒ.*?:\s*(.+)/i,
    rpGoals: /áƒ›áƒ˜áƒ–áƒœáƒ”áƒ‘áƒ˜ RP-áƒ¨áƒ˜.*?:\s*(.+)/i
  };
  
  for (const [key, pattern] of Object.entries(fieldPatterns)) {
    const match = text.match(pattern);
    if (match) {
      application.fields[key] = match[1].trim();
    }
  }
  
  return application;
}

/**
 * Calculate word count
 */
function getWordCount(text) {
  if (!text) return 0;
  return text.split(/\s+/).filter(word => word.length > 0).length;
}

/**
 * Evaluate lore and era consistency
 */
function evaluateLoreConsistency(application) {
  const { origin, currentState } = application.fields;
  const text = `${origin} ${currentState}`.toLowerCase();
  
  let score = 7.0;
  let assessment = 'áƒ’áƒáƒ áƒ”áƒ›áƒáƒ¡áƒ—áƒáƒœ áƒ—áƒáƒ•áƒ¡áƒ”áƒ‘áƒáƒ“áƒ˜áƒ, áƒ—áƒ£áƒ›áƒªáƒ áƒáƒ¦áƒ¬áƒ”áƒ áƒ áƒ«áƒáƒšáƒ˜áƒáƒœ áƒ–áƒáƒ’áƒáƒ“áƒ˜áƒ.';
  
  // Positive indicators
  const positiveKeywords = [
    'áƒ›áƒ”áƒ¥áƒ¡áƒ˜áƒ™', 'áƒáƒ›áƒ”áƒ áƒ˜áƒ™', 'áƒ¥áƒáƒšáƒáƒ¥', 'áƒ£áƒ‘áƒáƒœ', 'áƒáƒ¯áƒáƒ®', 'áƒ¤áƒ”áƒ áƒ›', 
    'áƒœáƒáƒ“áƒ˜áƒ ', 'áƒ¥áƒ£áƒ©áƒ', 'áƒ¡áƒáƒ¤áƒ”áƒš', 'áƒ¡áƒáƒ–áƒ¦áƒ•áƒáƒ ', 'valentine', 'saint denis'
  ];
  
  const negativeKeywords = [
    'áƒ—áƒáƒœáƒáƒ›áƒ”áƒ“áƒ áƒáƒ•áƒ”', 'áƒ¢áƒ”áƒšáƒ”áƒ¤áƒáƒœ', 'áƒ˜áƒœáƒ¢áƒ”áƒ áƒœáƒ”áƒ¢', 'áƒ›áƒáƒœáƒ¥áƒáƒœ', 'áƒ™áƒáƒ›áƒáƒ˜áƒ£áƒ¢áƒ”áƒ '
  ];
  
  const positiveCount = positiveKeywords.filter(kw => text.includes(kw)).length;
  const negativeCount = negativeKeywords.filter(kw => text.includes(kw)).length;
  
  if (positiveCount >= 3) {
    score += 1.5;
    assessment = 'áƒ™áƒáƒ áƒ’áƒáƒ“ áƒ¯áƒ“áƒ”áƒ‘áƒ Western áƒ’áƒáƒ áƒ”áƒ›áƒáƒ¡áƒ—áƒáƒœ áƒ“áƒ áƒ áƒ”áƒáƒšáƒ˜áƒ¡áƒ¢áƒ£áƒ áƒ˜áƒ.';
  }
  
  if (negativeCount > 0) {
    score -= 2.0;
    assessment = 'áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ¡ áƒáƒœáƒáƒ¥áƒ áƒáƒœáƒ˜áƒ–áƒ›áƒ”áƒ‘áƒ¡ áƒ“áƒ áƒáƒ  áƒ¨áƒ”áƒ”áƒ¡áƒáƒ‘áƒáƒ›áƒ”áƒ‘áƒ áƒ”áƒáƒáƒ¥áƒáƒ¡.';
  }
  
  // Check for specific details
  const wordCount = getWordCount(origin);
  if (wordCount >= 40) {
    score += 0.5;
  }
  
  return {
    score: Math.min(10, Math.max(1, score)),
    assessment
  };
}

/**
 * Evaluate character depth
 */
function evaluateCharacterDepth(application) {
  const { origin, weaknesses, character } = application.fields;
  const combined = `${origin} ${weaknesses} ${character}`.toLowerCase();
  
  let score = 6.5;
  let assessment = 'áƒáƒ  áƒ©áƒáƒœáƒ¡ áƒ™áƒáƒœáƒ™áƒ áƒ”áƒ¢áƒ£áƒšáƒ˜ áƒ›áƒáƒ•áƒšáƒ”áƒœáƒ áƒáƒœ áƒ¢áƒ áƒáƒ•áƒ›áƒ, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒáƒ”áƒ áƒ¡áƒáƒœáƒáƒŸáƒ¡ áƒ¤áƒáƒ áƒ›áƒ˜áƒ áƒ”áƒ‘áƒ¡.';
  
  // Look for trauma indicators
  const traumaKeywords = [
    'áƒ’áƒáƒ áƒ“áƒáƒ˜áƒªáƒ•áƒáƒš', 'áƒ“áƒáƒ˜áƒ¦áƒ£áƒ', 'áƒ“áƒáƒ™áƒáƒ áƒ’', 'áƒ›áƒáƒ™áƒš', 'áƒ¡áƒ˜áƒ™áƒ•áƒ“áƒ˜áƒš', 'áƒ¢áƒ áƒáƒ•áƒ›', 
    'áƒ›áƒ«áƒ˜áƒ›áƒ”', 'áƒ¡áƒ˜áƒ áƒ—áƒ£áƒš', 'áƒ¢áƒáƒœáƒ¯', 'áƒ¦áƒáƒ áƒ˜áƒ‘', 'áƒ£áƒ‘áƒ”áƒ“áƒ£áƒ áƒ”áƒ‘áƒ', 'áƒ¨áƒ˜áƒ›áƒ¨áƒ˜áƒš'
  ];
  
  // Look for emotional depth
  const emotionalKeywords = [
    'áƒ¨áƒ˜áƒ¨áƒ˜', 'áƒ”áƒ›áƒáƒªáƒ˜', 'áƒ¡áƒ”áƒ•áƒ“', 'áƒ›áƒáƒ áƒ¢áƒáƒáƒ‘', 'áƒ¡áƒ˜áƒœáƒáƒœáƒ£áƒš', 'áƒ©áƒáƒ™áƒ”áƒ¢',
    'áƒ›áƒ’áƒ áƒ«áƒœáƒáƒ‘áƒ˜áƒáƒ ', 'áƒ¨áƒ˜áƒœáƒáƒ’áƒáƒœ', 'áƒ¤áƒ¡áƒ˜áƒ¥áƒáƒšáƒáƒ’'
  ];
  
  const traumaCount = traumaKeywords.filter(kw => combined.includes(kw)).length;
  const emotionalCount = emotionalKeywords.filter(kw => combined.includes(kw)).length;
  
  if (traumaCount >= 2) {
    score += 1.0;
    assessment = 'áƒ¢áƒ áƒáƒ•áƒ›áƒ áƒ“áƒ áƒ«áƒšáƒ˜áƒ”áƒ áƒ˜ áƒ’áƒáƒ›áƒáƒªáƒ“áƒ˜áƒšáƒ”áƒ‘áƒ áƒ¥áƒ›áƒœáƒ˜áƒ¡ áƒ¡áƒ˜áƒ£áƒŸáƒ”áƒ¢áƒ£áƒ  áƒ¡áƒáƒ¤áƒ£áƒ«áƒ•áƒ”áƒšáƒ¡.';
  }
  
  if (emotionalCount >= 2) {
    score += 0.5;
    assessment = 'áƒ”áƒ›áƒáƒªáƒ˜áƒ£áƒ áƒ˜ áƒ¡áƒ˜áƒ¦áƒ áƒ›áƒ” áƒ“áƒ áƒ¤áƒ¡áƒ˜áƒ¥áƒáƒšáƒáƒ’áƒ˜áƒ£áƒ áƒ˜ áƒ¡áƒáƒ¤áƒ£áƒ«áƒ•áƒ”áƒšáƒ˜ áƒáƒ¨áƒ™áƒáƒ áƒáƒ.';
  }
  
  // Check for generic descriptions
  if (combined.includes('áƒ£áƒ‘áƒ áƒáƒšáƒ') && combined.includes('áƒ›áƒ¨áƒ•áƒ˜áƒ“áƒ˜') && traumaCount === 0) {
    score -= 1.0;
    assessment = 'áƒáƒ”áƒ áƒ¡áƒáƒœáƒáƒŸáƒ˜ áƒ–áƒ”áƒ“áƒ›áƒ”áƒ¢áƒáƒ“ áƒ–áƒáƒ’áƒáƒ“áƒ˜áƒ áƒ“áƒ áƒáƒ™áƒšáƒ˜áƒ áƒ£áƒœáƒ˜áƒ™áƒáƒšáƒ£áƒ áƒ˜ áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ”áƒ‘áƒ˜.';
  }
  
  return {
    score: Math.min(10, Math.max(1, score)),
    assessment
  };
}

/**
 * Evaluate motivation clarity
 */
function evaluateMotivationClarity(application) {
  const { rpGoals, currentState } = application.fields;
  const text = `${rpGoals} ${currentState}`.toLowerCase();
  
  let score = 7.0;
  let assessment = 'áƒ›áƒ˜áƒ–áƒœáƒ”áƒ‘áƒ˜ áƒ’áƒáƒ¡áƒáƒ’áƒ”áƒ‘áƒ˜áƒ, áƒ—áƒ£áƒ›áƒªáƒ áƒ–áƒáƒ’áƒáƒ“áƒ˜áƒ.';
  
  // Specific goals
  const specificGoals = [
    'áƒáƒ¯áƒáƒ®', 'áƒ áƒáƒœáƒ©áƒ', 'áƒ›áƒáƒ¦áƒáƒ–áƒ˜', 'áƒ‘áƒ˜áƒ–áƒœáƒ”áƒ¡', 'áƒáƒ•áƒ¢áƒáƒ áƒ˜áƒ¢áƒ”áƒ¢', 'áƒ¨áƒ”áƒ áƒ˜áƒ¤', 
    'áƒ›áƒáƒ áƒ¨áƒáƒš', 'áƒ•áƒáƒ­áƒ áƒáƒ‘', 'áƒœáƒáƒ“áƒ˜áƒ áƒáƒ‘', 'áƒ¡áƒáƒ™áƒ£áƒ—áƒáƒ áƒ˜', 'áƒ“áƒáƒ¡áƒáƒ®áƒšáƒ“'
  ];
  
  // Generic/vague goals
  const genericGoals = [
    'áƒ¤áƒ£áƒš', 'áƒ«áƒáƒšáƒ', 'áƒ’áƒáƒ•áƒšáƒ”áƒœ', 'áƒ¬áƒ˜áƒœáƒ¡áƒ•áƒš', 'áƒ¬áƒáƒ áƒ›áƒáƒ¢áƒ”áƒ‘'
  ];
  
  const specificCount = specificGoals.filter(kw => text.includes(kw)).length;
  const genericCount = genericGoals.filter(kw => text.includes(kw)).length;
  
  if (specificCount >= 2) {
    score += 1.0;
    assessment = 'áƒ™áƒáƒœáƒ™áƒ áƒ”áƒ¢áƒ£áƒšáƒ˜ áƒ“áƒ áƒ’áƒ áƒ«áƒ”áƒšáƒ•áƒáƒ“áƒ˜áƒáƒœáƒ˜ áƒ›áƒ˜áƒ–áƒœáƒ”áƒ‘áƒ˜ áƒ›áƒ™áƒáƒ¤áƒ˜áƒáƒ.';
  } else if (genericCount >= 2 && specificCount === 0) {
    score -= 0.5;
    assessment = 'áƒ›áƒ˜áƒ–áƒœáƒ”áƒ‘áƒ˜ áƒ–áƒ”áƒ“áƒ›áƒ”áƒ¢áƒáƒ“ áƒ–áƒáƒ’áƒáƒ“áƒ˜áƒ áƒ“áƒ áƒáƒ áƒ áƒáƒ”áƒ áƒ¡áƒáƒœáƒáƒšáƒ£áƒ áƒ˜.';
  }
  
  return {
    score: Math.min(10, Math.max(1, score)),
    assessment
  };
}

/**
 * Evaluate RP sustainability
 */
function evaluateRPSustainability(application) {
  const { rpGoals, character, conflictAttitude } = application.fields;
  const text = `${rpGoals} ${character} ${conflictAttitude}`.toLowerCase();
  
  let score = 7.5;
  let assessment = 'áƒáƒ”áƒ áƒ¡áƒáƒœáƒáƒŸáƒ˜ áƒ¨áƒ”áƒ˜áƒ«áƒšáƒ”áƒ‘áƒ áƒ’áƒáƒœáƒ•áƒ˜áƒ—áƒáƒ áƒ“áƒ”áƒ¡, áƒ›áƒáƒ’áƒ áƒáƒ› áƒ¡áƒáƒ­áƒ˜áƒ áƒáƒ”áƒ‘áƒ¡ áƒ™áƒáƒœáƒ¢áƒ áƒáƒšáƒ¡.';
  
  // Positive RP indicators
  const positiveRP = [
    'áƒ¡áƒáƒªáƒ˜áƒáƒšáƒ£áƒ ', 'áƒ£áƒ áƒ—áƒ˜áƒ”áƒ áƒ—áƒáƒ‘', 'áƒ—áƒáƒœáƒáƒ›áƒ¨áƒ áƒáƒ›áƒšáƒáƒ‘', 'áƒ’áƒ£áƒœáƒ“', 'áƒ›áƒ”áƒ’áƒáƒ‘áƒ ',
    'áƒ”áƒ™áƒáƒœáƒáƒ›áƒ˜áƒ™', 'áƒ•áƒáƒ­áƒ áƒáƒ‘', 'áƒ›áƒ£áƒ¨áƒáƒáƒ‘', 'áƒ’áƒáƒœáƒ•áƒ˜áƒ—áƒáƒ áƒ”áƒ‘'
  ];
  
  // Negative RP indicators
  const negativeRP = [
    'áƒ›áƒáƒ•áƒ™áƒšáƒáƒ•', 'áƒ“áƒáƒ•áƒáƒœáƒ’áƒ áƒ”áƒ•', 'áƒ’áƒáƒ•áƒáƒœáƒáƒ“áƒ’áƒ£áƒ ', 'áƒ¨áƒ£áƒ '
  ];
  
  const positiveCount = positiveRP.filter(kw => text.includes(kw)).length;
  const negativeCount = negativeRP.filter(kw => text.includes(kw)).length;
  
  if (positiveCount >= 2) {
    score += 0.5;
    assessment = 'áƒ¡áƒáƒªáƒ˜áƒáƒšáƒ£áƒ áƒ˜ áƒ“áƒ áƒ”áƒ™áƒáƒœáƒáƒ›áƒ˜áƒ™áƒ£áƒ áƒ˜ RP áƒ®áƒáƒ–áƒ”áƒ‘áƒ˜ áƒ’áƒáƒœáƒ•áƒ˜áƒ—áƒáƒ áƒ”áƒ‘áƒáƒ“áƒ˜áƒ.';
  }
  
  if (negativeCount > 0) {
    score -= 1.0;
    assessment = 'áƒ«áƒáƒšáƒáƒ“áƒáƒ‘áƒáƒ–áƒ” áƒáƒ áƒ˜áƒ”áƒœáƒ¢áƒáƒªáƒ˜áƒ áƒ¡áƒáƒ­áƒ˜áƒ áƒáƒ”áƒ‘áƒ¡ áƒ™áƒáƒœáƒ¢áƒ áƒáƒšáƒ¡ RP-áƒ¨áƒ˜.';
  }
  
  return {
    score: Math.min(10, Math.max(1, score)),
    assessment
  };
}

/**
 * Evaluate risks and red flags
 */
function evaluateRisks(application) {
  const { rpGoals, conflictAttitude, character } = application.fields;
  const text = `${rpGoals} ${conflictAttitude} ${character}`.toLowerCase();
  
  let score = 8.0;
  let assessment = 'áƒ›áƒ˜áƒœáƒ˜áƒ›áƒáƒšáƒ£áƒ áƒ˜ áƒ áƒ˜áƒ¡áƒ™áƒ”áƒ‘áƒ˜, áƒ™áƒáƒœáƒ¢áƒ áƒáƒšáƒ˜áƒ áƒ”áƒ‘áƒáƒ“áƒ˜ áƒ¥áƒªáƒ”áƒ•áƒ.';
  
  // Red flags
  const redFlags = {
    violence: ['áƒ«áƒáƒšáƒáƒ“áƒáƒ‘', 'áƒ¡áƒ˜áƒ¡áƒáƒ¡áƒ¢áƒ˜áƒ™', 'áƒ¡áƒáƒ¡áƒ¢áƒ˜áƒ™', 'áƒ›áƒáƒ•áƒ™áƒšáƒáƒ•', 'áƒ¡áƒ˜áƒ¡áƒ®áƒš'],
    power: ['áƒ«áƒáƒšáƒáƒ£áƒ¤áƒšáƒ”áƒ‘', 'áƒ’áƒáƒ•áƒšáƒ”áƒœ', 'áƒ“áƒáƒ›áƒ˜áƒœáƒ˜áƒ áƒ”áƒ‘', 'áƒ›áƒáƒ•áƒ˜áƒ’áƒ”áƒ‘', 'áƒáƒ•áƒ¢áƒáƒ áƒ˜áƒ¢áƒ”áƒ¢'],
    revenge: ['áƒ¨áƒ£áƒ ', 'áƒ¨áƒ£áƒ áƒ˜áƒ¡áƒ«áƒ˜áƒ”áƒ‘', 'áƒ’áƒáƒ›áƒáƒ•áƒ˜áƒ®áƒ“', 'áƒ’áƒáƒ“áƒáƒ•áƒ£áƒ®áƒ“'],
    chaos: ['áƒ¥áƒáƒáƒ¡', 'áƒ áƒ”áƒáƒ˜áƒ áƒ”áƒ‘', 'áƒ’áƒáƒ›áƒáƒ•áƒ£áƒ•áƒš', 'áƒáƒ áƒ”áƒ£áƒšáƒáƒ‘']
  };
  
  let flagCount = 0;
  let mainRisk = '';
  
  for (const [category, keywords] of Object.entries(redFlags)) {
    const count = keywords.filter(kw => text.includes(kw)).length;
    if (count > 0) {
      flagCount += count;
      if (category === 'violence') mainRisk = 'áƒ«áƒáƒšáƒáƒ“áƒáƒ‘áƒáƒ–áƒ” áƒ¤áƒáƒ™áƒ£áƒ¡áƒ˜';
      else if (category === 'power') mainRisk = 'áƒ«áƒáƒšáƒáƒ£áƒ¤áƒšáƒ”áƒ‘áƒáƒ–áƒ” áƒ¤áƒáƒ™áƒ£áƒ¡áƒ˜';
      else if (category === 'revenge') mainRisk = 'áƒ¨áƒ£áƒ áƒ˜áƒ¡áƒ«áƒ˜áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¢áƒ˜áƒ•áƒ˜';
      else if (category === 'chaos') mainRisk = 'áƒ¥áƒáƒáƒ¡áƒ£áƒ áƒ˜ áƒ¥áƒªáƒ”áƒ•áƒ';
    }
  }
  
  if (flagCount >= 3) {
    score = 6.0;
    assessment = `${mainRisk} â†’ áƒ›áƒáƒ¦áƒáƒšáƒ˜ RDM/Power-RP áƒ áƒ˜áƒ¡áƒ™áƒ˜.`;
  } else if (flagCount >= 1) {
    score = 7.0;
    assessment = `${mainRisk} â†’ áƒ¡áƒáƒ­áƒ˜áƒ áƒáƒ”áƒ‘áƒ¡ áƒ™áƒáƒœáƒ¢áƒ áƒáƒšáƒ¡ RP-áƒ¨áƒ˜.`;
  }
  
  // Positive indicators
  const positiveIndicators = ['áƒ›áƒ¨áƒ•áƒ˜áƒ“', 'áƒ“áƒ˜áƒáƒšáƒáƒ›áƒáƒ¢', 'áƒ¡áƒáƒ£áƒ‘áƒáƒ ', 'áƒ¨áƒ”áƒ—áƒáƒœáƒ®áƒ›áƒ”áƒ‘', 'áƒ›áƒáƒšáƒáƒáƒáƒ áƒáƒ™áƒ”áƒ‘'];
  const positiveCount = positiveIndicators.filter(kw => text.includes(kw)).length;
  
  if (positiveCount >= 2 && flagCount === 0) {
    score = 8.5;
    assessment = 'áƒ“áƒáƒ‘áƒáƒšáƒáƒœáƒ¡áƒ”áƒ‘áƒ£áƒšáƒ˜ áƒ›áƒ˜áƒ“áƒ’áƒáƒ›áƒ áƒ™áƒáƒœáƒ¤áƒšáƒ˜áƒ¥áƒ¢áƒ˜áƒ¡áƒáƒ“áƒ›áƒ˜.';
  }
  
  return {
    score: Math.min(10, Math.max(1, score)),
    assessment
  };
}

/**
 * Evaluate language and structure
 */
function evaluateLanguageStructure(application) {
  const { fields } = application;
  
  let score = 8.0;
  let assessment = 'áƒ¢áƒ”áƒ¥áƒ¡áƒ¢áƒ˜ áƒ’áƒáƒ¡áƒáƒ’áƒ”áƒ‘áƒ˜áƒ áƒ“áƒ áƒ’áƒáƒ›áƒáƒ áƒ—áƒ£áƒšáƒ˜áƒ.';
  
  // Check if all fields are filled
  const requiredFields = ['name', 'age', 'origin', 'character', 'rpGoals'];
  const filledFields = requiredFields.filter(field => fields[field] && fields[field].length > 10);
  
  if (filledFields.length < requiredFields.length) {
    score -= 2.0;
    assessment = 'áƒáƒ áƒáƒ¡áƒ áƒ£áƒšáƒ˜ áƒ’áƒáƒœáƒáƒªáƒ®áƒáƒ“áƒ˜, áƒ–áƒáƒ’áƒ˜áƒ”áƒ áƒ—áƒ˜ áƒ•áƒ”áƒšáƒ˜ áƒªáƒáƒ áƒ˜áƒ”áƒšáƒ˜áƒ.';
  }
  
  // Check word counts
  const originWords = getWordCount(fields.origin);
  const characterWords = getWordCount(fields.character);
  
  if (originWords < 20 || characterWords < 20) {
    score -= 1.0;
    assessment = 'áƒ«áƒáƒšáƒ˜áƒáƒœ áƒ›áƒáƒ™áƒšáƒ” áƒáƒ¦áƒ¬áƒ”áƒ áƒ, áƒáƒ™áƒšáƒ˜áƒ áƒ“áƒ”áƒ¢áƒáƒšáƒ”áƒ‘áƒ˜.';
  }
  
  if (originWords > 50 && characterWords > 50) {
    score += 0.5;
    assessment = 'áƒ“áƒ”áƒ¢áƒáƒšáƒ£áƒ áƒ˜ áƒ“áƒ áƒ©áƒáƒ›áƒáƒ§áƒáƒšáƒ˜áƒ‘áƒ”áƒ‘áƒ£áƒšáƒ˜ áƒ¢áƒ”áƒ¥áƒ¡áƒ¢áƒ˜.';
  }
  
  return {
    score: Math.min(10, Math.max(1, score)),
    assessment
  };
}

/**
 * Main evaluation function
 */
export function evaluateWhitelist(text) {
  if (!text || text.trim().length < 50) {
    return {
      error: 'áƒ’áƒáƒœáƒáƒªáƒ®áƒáƒ“áƒ˜ áƒ–áƒ”áƒ“áƒ›áƒ”áƒ¢áƒáƒ“ áƒ›áƒáƒ™áƒšáƒ”áƒ áƒáƒœ áƒªáƒáƒ áƒ˜áƒ”áƒšáƒ˜áƒ',
      status: 'rejected'
    };
  }
  
  const application = parseApplication(text);
  
  // Evaluate each criteria
  const loreResult = evaluateLoreConsistency(application);
  const depthResult = evaluateCharacterDepth(application);
  const motivationResult = evaluateMotivationClarity(application);
  const sustainabilityResult = evaluateRPSustainability(application);
  const risksResult = evaluateRisks(application);
  const languageResult = evaluateLanguageStructure(application);
  
  // Calculate weighted score
  const scores = {
    loreConsistency: loreResult.score,
    characterDepth: depthResult.score,
    motivationClarity: motivationResult.score,
    rpSustainability: sustainabilityResult.score,
    risks: risksResult.score,
    languageStructure: languageResult.score
  };
  
  let totalScore = 0;
  for (const [key, score] of Object.entries(scores)) {
    totalScore += score * EVALUATION_CRITERIA[key].weight;
  }
  
  // Round to 1 decimal
  const finalScore = Math.round(totalScore * 10) / 10;
  
  // Determine status
  const status = finalScore >= MINIMUM_PASSING_SCORE ? 'accepted' : 'rejected';
  
  // Generate recommendations
  const recommendations = [];
  if (scores.characterDepth < 7) {
    recommendations.push('áƒ“áƒáƒáƒ›áƒáƒ¢áƒ”áƒ— áƒ™áƒáƒœáƒ™áƒ áƒ”áƒ¢áƒ£áƒšáƒ˜ áƒ›áƒáƒ•áƒšáƒ”áƒœáƒ”áƒ‘áƒ˜ áƒ“áƒ áƒ¢áƒ áƒáƒ•áƒ›áƒ áƒáƒ”áƒ áƒ¡áƒáƒœáƒáƒŸáƒ˜áƒ¡ áƒ¤áƒáƒ áƒ›áƒ˜áƒ áƒ”áƒ‘áƒ˜áƒ¡áƒ—áƒ•áƒ˜áƒ¡');
  }
  if (scores.loreConsistency < 7) {
    recommendations.push('áƒ“áƒáƒáƒ™áƒáƒœáƒ™áƒ áƒ”áƒ¢áƒ”áƒ— áƒáƒ“áƒ’áƒ˜áƒšáƒ”áƒ‘áƒ˜ áƒ“áƒ áƒ”áƒáƒáƒ¥áƒ˜áƒ¡ áƒ™áƒáƒœáƒ¢áƒ”áƒ¥áƒ¡áƒ¢áƒ˜');
  }
  if (scores.motivationClarity < 7) {
    recommendations.push('áƒ’áƒáƒœáƒ¡áƒáƒ–áƒ¦áƒ•áƒ áƒ”áƒ— áƒ£áƒ¤áƒ áƒ áƒ™áƒáƒœáƒ™áƒ áƒ”áƒ¢áƒ£áƒšáƒ˜ áƒ“áƒ áƒáƒ”áƒ áƒ¡áƒáƒœáƒáƒšáƒ£áƒ áƒ˜ áƒ›áƒ˜áƒ–áƒœáƒ”áƒ‘áƒ˜');
  }
  if (scores.risks < 7) {
    recommendations.push('áƒ¨áƒ”áƒáƒ›áƒªáƒ˜áƒ áƒ”áƒ— áƒ«áƒáƒšáƒáƒ“áƒáƒ‘áƒáƒ–áƒ” áƒáƒ áƒ˜áƒ”áƒœáƒ¢áƒáƒªáƒ˜áƒ áƒ“áƒ áƒ“áƒáƒáƒ›áƒáƒ¢áƒ”áƒ— RP áƒáƒšáƒ¢áƒ”áƒ áƒœáƒáƒ¢áƒ˜áƒ•áƒ”áƒ‘áƒ˜');
  }
  
  return {
    application,
    scores,
    finalScore,
    status,
    minimumScore: MINIMUM_PASSING_SCORE,
    assessments: {
      loreConsistency: loreResult.assessment,
      characterDepth: depthResult.assessment,
      motivationClarity: motivationResult.assessment,
      rpSustainability: sustainabilityResult.assessment,
      risks: risksResult.assessment,
      languageStructure: languageResult.assessment
    },
    recommendations,
    timestamp: new Date().toISOString()
  };
}
